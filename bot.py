import logging
import os
from typing import Dict, List, Optional, Tuple
import traceback
import asyncio
from datetime import datetime, timedelta

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler,
    ContextTypes, filters, ConversationHandler
)

from database import Database
from scraper import ProductScraper
from config import STORES, HEADERS, PRODUCT_CHECK_INTERVAL_MINUTES

# Configure logger for this module
logger = logging.getLogger(__name__)

# Conversation states
SELECTING_STORE, ENTERING_URL, CONFIRMING_PRODUCT, MONITORING = range(4)

class TelegramBot:
    def __init__(self):
        """Initialize the Telegram bot with required components"""
        # Get token from environment variable
        self.token = os.environ.get("TELEGRAM_TOKEN")
        if not self.token:
            raise ValueError("TELEGRAM_TOKEN environment variable not set")
        
        # Initialize database
        self.db = Database()
        
        # Initialize product scraper
        self.scraper = ProductScraper(HEADERS)
        
        # Create application
        self.application = Application.builder().token(self.token).build()
        
        # Add handlers
        self._add_handlers()
        
        logger.info("Bot initialized successfully")
    
    def _add_handlers(self):
        """Add all command and callback handlers to the application"""
        # Command handlers
        self.application.add_handler(CommandHandler("start", self._start_command))
        self.application.add_handler(CommandHandler("help", self._help_command))
        self.application.add_handler(CommandHandler("list", self._list_command))
        
        # Track product conversation flow
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler("track", self._track_command)],
            states={
                SELECTING_STORE: [
                    CallbackQueryHandler(self._store_selected, pattern=r'^store_\w+$')
                ],
                ENTERING_URL: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._url_received)
                ],
                CONFIRMING_PRODUCT: [
                    CallbackQueryHandler(self._confirm_product, pattern=r'^confirm_(yes|no)$')
                ]
            },
            fallbacks=[CommandHandler("cancel", self._cancel_tracking)],
        )
        self.application.add_handler(conv_handler)
        
        # Product action handlers
        self.application.add_handler(CallbackQueryHandler(self._remove_product, pattern=r'^remove_\d+$'))
        self.application.add_handler(CallbackQueryHandler(self._check_product, pattern=r'^check_\d+$'))
        
        # Error handler
        self.application.add_error_handler(self._error_handler)

    async def _start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle the /start command - introduce the bot and its functions"""
        user = update.effective_user
        await update.message.reply_html(
            f"üëã Merhaba {user.mention_html()}!\n\n"
            f"üîç Ben bir √ºr√ºn takip botuyum. Favori maƒüazalarƒ±nƒ±zdaki √ºr√ºnlerin "
            f"fiyat deƒüi≈üimlerini ve stok durumlarƒ±nƒ± takip edebilirsiniz.\n\n"
            f"üõ† Komutlar:\n"
            f"/track - Yeni bir √ºr√ºn takibi ba≈ülat\n"
            f"/list - Takip ettiƒüiniz √ºr√ºnleri listele\n"
            f"/help - Yardƒ±m men√ºs√º\n\n"
            f"Hadi ba≈ülayalƒ±m! Takip etmek istediƒüiniz bir √ºr√ºn i√ßin /track komutunu kullanƒ±n."
        )
        
        # Ensure user exists in database
        self.db.add_user(update.effective_user.id)

    async def _help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle the /help command - display help information"""
        await update.message.reply_text(
            "üìò *Bot Kullanƒ±m Rehberi*\n\n"
            "*Komutlar:*\n"
            "/start - Botu ba≈ülat\n"
            "/track - Yeni bir √ºr√ºn takibi ba≈ülat\n"
            "/list - Takip ettiƒüiniz √ºr√ºnleri listele\n"
            "/help - Bu yardƒ±m mesajƒ±nƒ± g√∂ster\n\n"
            "*√úr√ºn Takibi Nasƒ±l √áalƒ±≈üƒ±r:*\n"
            "1. /track komutunu kullanƒ±n\n"
            "2. Listeden bir maƒüaza se√ßin\n"
            "3. Takip etmek istediƒüiniz √ºr√ºn√ºn URL'sini g√∂nderin\n"
            "4. Bilgileri onaylayƒ±n\n\n"
            "*Desteklenen Maƒüazalar:*\n" + 
            "\n".join(f"‚Ä¢ {store['name']}" for store in STORES),
            parse_mode='Markdown'
        )

    async def _track_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Start the product tracking conversation flow"""
        # Create keyboard with store options
        keyboard = []
        for store in STORES:
            keyboard.append([InlineKeyboardButton(
                text=store['name'], 
                callback_data=f"store_{store['id']}"
            )])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "Hangi maƒüazadan √ºr√ºn takip etmek istiyorsunuz?",
            reply_markup=reply_markup
        )
        
        return SELECTING_STORE

    async def _store_selected(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Handle store selection for product tracking"""
        query = update.callback_query
        await query.answer()
        
        store_id = query.data.split('_')[1]
        context.user_data['selected_store'] = store_id
        
        # Find store name
        store_name = next((s['name'] for s in STORES if s['id'] == store_id), "Se√ßilen maƒüaza")
        
        await query.edit_message_text(
            f"{store_name} maƒüazasƒ±ndan bir √ºr√ºn takip edeceksiniz.\n\n"
            f"L√ºtfen √ºr√ºn sayfasƒ±nƒ±n tam URL'sini girin:"
        )
        
        return ENTERING_URL

    async def _url_received(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Process the product URL entered by the user"""
        url = update.message.text.strip()
        store_id = context.user_data.get('selected_store')
        
        # Save URL to context
        context.user_data['product_url'] = url
        
        await update.message.reply_text("√úr√ºn bilgileri alƒ±nƒ±yor, l√ºtfen bekleyin...")
        
        try:
            # Get product info using scraper
            product_info = self.scraper.get_product_info(store_id, url)
            
            if not product_info:
                await update.message.reply_text(
                    "‚ö†Ô∏è Bu URL'den √ºr√ºn bilgilerini alamadƒ±m. L√ºtfen URL'i kontrol edip tekrar deneyin."
                )
                return ConversationHandler.END
            
            # Save product info to context
            context.user_data['product_info'] = product_info
            
            # Show product info and ask for confirmation
            keyboard = [
                [
                    InlineKeyboardButton("‚úì Evet", callback_data="confirm_yes"),
                    InlineKeyboardButton("‚úó Hayƒ±r", callback_data="confirm_no")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Format price with currency
            price_formatted = f"{product_info['price']} TL" if product_info['price'] else "Fiyat bilgisi alƒ±namadƒ±"
            
            await update.message.reply_text(
                f"*√úr√ºn Bilgileri:*\n\n"
                f"üìå *ƒ∞sim:* {product_info['title']}\n"
                f"üí∞ *Fiyat:* {price_formatted}\n"
                f"üè™ *Stok Durumu:* {'‚úÖ Stokta' if product_info['in_stock'] else '‚ùå Stokta deƒüil'}\n\n"
                f"Bu √ºr√ºn√º takip listesine eklemek istiyor musunuz?",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            
            return CONFIRMING_PRODUCT
            
        except Exception as e:
            logger.error(f"Error processing URL: {e}", exc_info=True)
            await update.message.reply_text(
                "‚ö†Ô∏è √úr√ºn bilgilerini alƒ±rken bir hata olu≈ütu. L√ºtfen ge√ßerli bir URL girdiƒüinizden emin olun ve tekrar deneyin."
            )
            return ConversationHandler.END

    async def _confirm_product(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Handle product confirmation for tracking"""
        query = update.callback_query
        await query.answer()
        
        user_choice = query.data.split('_')[1]
        
        if user_choice == 'yes':
            try:
                # Get data from context
                store_id = context.user_data.get('selected_store')
                url = context.user_data.get('product_url')
                product_info = context.user_data.get('product_info')
                
                # Add product to database
                product_id = self.db.add_product(
                    user_id=update.effective_user.id,
                    store_id=store_id,
                    url=url,
                    title=product_info['title'],
                    price=product_info['price'],
                    in_stock=product_info['in_stock']
                )
                
                await query.edit_message_text(
                    f"‚úÖ *{product_info['title']}* √ºr√ºn√º ba≈üarƒ±yla takip listesine eklendi.\n\n"
                    f"Fiyat veya stok durumu deƒüi≈ütiƒüinde sizi bilgilendireceƒüim!\n\n"
                    f"Takip ettiƒüiniz t√ºm √ºr√ºnleri g√∂rmek i√ßin /list komutunu kullanabilirsiniz.",
                    parse_mode='Markdown'
                )
                
            except Exception as e:
                logger.error(f"Error adding product: {e}", exc_info=True)
                await query.edit_message_text(
                    "‚ö†Ô∏è √úr√ºn eklenirken bir hata olu≈ütu. L√ºtfen tekrar deneyin."
                )
        else:
            await query.edit_message_text(
                "ƒ∞≈ülem iptal edildi. Ba≈üka bir √ºr√ºn eklemek i√ßin /track komutunu kullanabilirsiniz."
            )
        
        # Clear user data
        context.user_data.clear()
        
        return ConversationHandler.END

    async def _cancel_tracking(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Cancel the product tracking conversation"""
        await update.message.reply_text(
            "√úr√ºn takip i≈ülemi iptal edildi. Ana men√ºye d√∂nmek i√ßin /start komutunu kullanabilirsiniz."
        )
        context.user_data.clear()
        return ConversationHandler.END

    async def _list_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """List all tracked products for the user"""
        user_id = update.effective_user.id
        products = self.db.get_user_products(user_id)
        
        if not products:
            await update.message.reply_text(
                "üìù Hen√ºz takip ettiƒüiniz bir √ºr√ºn bulunmuyor.\n\n"
                "√úr√ºn eklemek i√ßin /track komutunu kullanabilirsiniz."
            )
            return
        
        await update.message.reply_text(
            f"üõí *Takip Ettiƒüiniz √úr√ºnler ({len(products)})*\n\n"
            f"Her √ºr√ºn i√ßin g√ºncel durumu kontrol edebilir veya takibi sonlandƒ±rabilirsiniz:",
            parse_mode='Markdown'
        )
        
        # Send each product as a separate message with action buttons
        for product in products:
            # Format price
            price_text = f"{product['price']} TL" if product['price'] else "Fiyat bilgisi yok"
            
            # Create inline keyboard
            keyboard = [
                [
                    InlineKeyboardButton("üîÑ G√ºncelle", callback_data=f"check_{product['id']}"),
                    InlineKeyboardButton("‚ùå Takibi Bƒ±rak", callback_data=f"remove_{product['id']}")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Get store name
            store_name = next((s['name'] for s in STORES if s['id'] == product['store_id']), "Bilinmeyen Maƒüaza")
            
            await update.message.reply_text(
                f"üìå *{product['title']}*\n"
                f"üí∞ *Fiyat:* {price_text}\n"
                f"üè™ *Stok Durumu:* {'‚úÖ Stokta' if product['in_stock'] else '‚ùå Stokta deƒüil'}\n"
                f"üõí *Maƒüaza:* {store_name}\n"
                f"üìÖ *Eklenme:* {product['created_at']}\n"
                f"üìÖ *Son G√ºncelleme:* {product['updated_at']}\n",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

    async def _remove_product(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Remove a product from tracking list"""
        query = update.callback_query
        await query.answer()
        
        product_id = int(query.data.split('_')[1])
        user_id = update.effective_user.id
        
        # Check product ownership
        if not self.db.is_product_owner(user_id, product_id):
            await query.edit_message_text("‚ö†Ô∏è Bu √ºr√ºn√º silme yetkiniz yok.")
            return
        
        product = self.db.get_product(product_id)
        success = self.db.remove_product(product_id)
        
        if success:
            await query.edit_message_text(
                f"‚úÖ *{product['title']}* √ºr√ºn√º takip listenizden kaldƒ±rƒ±ldƒ±.",
                parse_mode='Markdown'
            )
        else:
            await query.edit_message_text(
                "‚ö†Ô∏è √úr√ºn kaldƒ±rƒ±lƒ±rken bir hata olu≈ütu. L√ºtfen tekrar deneyin."
            )

    async def _check_product(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Check current status of a product"""
        query = update.callback_query
        await query.answer()
        
        product_id = int(query.data.split('_')[1])
        user_id = update.effective_user.id
        
        # Check product ownership
        if not self.db.is_product_owner(user_id, product_id):
            await query.edit_message_text("‚ö†Ô∏è Bu √ºr√ºn√º kontrol etme yetkiniz yok.")
            return
        
        # Get product from database
        product = self.db.get_product(product_id)
        
        await query.edit_message_text(
            "√úr√ºn bilgileri g√ºncelleniyor, l√ºtfen bekleyin..."
        )
        
        try:
            # Get current product info
            product_info = self.scraper.get_product_info(product['store_id'], product['url'])
            
            if not product_info:
                await query.edit_message_text(
                    "‚ö†Ô∏è √úr√ºn bilgileri alƒ±namadƒ±. L√ºtfen daha sonra tekrar deneyin."
                )
                return
            
            # Format prices
            old_price_text = f"{product['price']} TL" if product['price'] else "Fiyat bilgisi yok"
            new_price_text = f"{product_info['price']} TL" if product_info['price'] else "Fiyat bilgisi yok"
            
            # Create status message
            message = f"üîÑ *{product_info['title']}* g√ºncel durumu:\n\n"
            
            # Check price difference
            if product_info['price'] != product['price']:
                if product_info['price'] and product['price']:
                    price_diff = float(product_info['price']) - float(product['price'])
                    if price_diff < 0:
                        message += f"üí∞ *Fiyat:* {old_price_text} ‚û°Ô∏è {new_price_text} (üéâ {abs(price_diff):.2f} TL indirim!)\n"
                    else:
                        message += f"üí∞ *Fiyat:* {old_price_text} ‚û°Ô∏è {new_price_text} (üìà {price_diff:.2f} TL artƒ±≈ü)\n"
                else:
                    message += f"üí∞ *Fiyat:* {old_price_text} ‚û°Ô∏è {new_price_text}\n"
            else:
                message += f"üí∞ *Fiyat:* {new_price_text} (deƒüi≈ümedi)\n"
            
            # Check stock difference
            if product_info['in_stock'] != product['in_stock']:
                if product_info['in_stock']:
                    message += f"üè™ *Stok Durumu:* ‚ùå Stokta deƒüil ‚û°Ô∏è ‚úÖ Stokta (Stoka girdi!)\n"
                else:
                    message += f"üè™ *Stok Durumu:* ‚úÖ Stokta ‚û°Ô∏è ‚ùå Stokta deƒüil (T√ºkendi!)\n"
            else:
                message += f"üè™ *Stok Durumu:* {'‚úÖ Stokta' if product_info['in_stock'] else '‚ùå Stokta deƒüil'} (deƒüi≈ümedi)\n"
            
            # Get store name
            store_name = next((s['name'] for s in STORES if s['id'] == product['store_id']), "Bilinmeyen Maƒüaza")
            message += f"üõí *Maƒüaza:* {store_name}\n"
            
            # Add action buttons
            keyboard = [
                [
                    InlineKeyboardButton("üîÑ Tekrar G√ºncelle", callback_data=f"check_{product_id}"),
                    InlineKeyboardButton("‚ùå Takibi Bƒ±rak", callback_data=f"remove_{product_id}")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Update product in database
            self.db.update_product(
                product_id=product_id,
                title=product_info['title'],
                price=product_info['price'],
                in_stock=product_info['in_stock']
            )
            
            await query.edit_message_text(
                message,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            
        except Exception as e:
            logger.error(f"Error checking product: {e}", exc_info=True)
            await query.edit_message_text(
                "‚ö†Ô∏è √úr√ºn kontrol√º sƒ±rasƒ±nda bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin."
            )

    async def _error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle errors in bot updates"""
        # Log the error
        logger.error(f"Update caused error: {context.error}", exc_info=context.error)
        
        # Get traceback info
        tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
        tb_string = "".join(tb_list)
        
        # Log detailed error info
        logger.error(f"Traceback: {tb_string}")
        
        # Inform user of the error if possible
        if update and hasattr(update, 'effective_message') and update.effective_message:
            await update.effective_message.reply_text(
                "‚ö†Ô∏è Bot i≈ülem sƒ±rasƒ±nda bir hatayla kar≈üƒ±la≈ütƒ±. L√ºtfen daha sonra tekrar deneyin.\n"
                "Sorun devam ederse, botun yeniden ba≈ülatƒ±lmasƒ± gerekebilir."
            )

    async def _scheduled_check_products(self, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Callback for scheduled product check job"""
        await self._check_all_products()
        
    async def _check_all_products(self) -> None:
        """Check all products for updates and notify users"""
        logger.info("Starting periodic check of all products")
        
        products = self.db.get_all_products()
        for product in products:
            try:
                # Get current product info
                product_info = self.scraper.get_product_info(product['store_id'], product['url'])
                
                if not product_info:
                    logger.warning(f"Could not get info for product {product['id']}")
                    continue
                
                # Check for changes
                price_changed = product_info['price'] != product['price']
                stock_changed = product_info['in_stock'] != product['in_stock']
                
                # Notify user if needed
                if price_changed or stock_changed:
                    # Format prices
                    old_price_text = f"{product['price']} TL" if product['price'] else "Fiyat bilgisi yok"
                    new_price_text = f"{product_info['price']} TL" if product_info['price'] else "Fiyat bilgisi yok"
                    
                    # Create notification message
                    message = f"üîî *Takip Ettiƒüiniz √úr√ºn G√ºncellendi!*\n\n"
                    message += f"üìå *{product_info['title']}*\n\n"
                    
                    # Price change message
                    if price_changed and product_info['price'] and product['price']:
                        price_diff = float(product_info['price']) - float(product['price'])
                        if price_diff < 0:
                            message += f"üí∞ *Fiyat:* {old_price_text} ‚û°Ô∏è {new_price_text} (üéâ {abs(price_diff):.2f} TL indirim!)\n"
                        else:
                            message += f"üí∞ *Fiyat:* {old_price_text} ‚û°Ô∏è {new_price_text} (üìà {price_diff:.2f} TL artƒ±≈ü)\n"
                    elif price_changed:
                        message += f"üí∞ *Fiyat:* {old_price_text} ‚û°Ô∏è {new_price_text}\n"
                    
                    # Stock change message
                    if stock_changed:
                        if product_info['in_stock']:
                            message += f"üè™ *Stok Durumu:* ‚ùå Stokta deƒüil ‚û°Ô∏è ‚úÖ Stokta (Stoka girdi!)\n"
                        else:
                            message += f"üè™ *Stok Durumu:* ‚úÖ Stokta ‚û°Ô∏è ‚ùå Stokta deƒüil (T√ºkendi!)\n"
                    
                    # Add URL
                    message += f"\n[√úr√ºn Sayfasƒ±nƒ± Ziyaret Et]({product['url']})"
                    
                    # Add action buttons
                    keyboard = [
                        [
                            InlineKeyboardButton("üîÑ G√ºncelle", callback_data=f"check_{product['id']}"),
                            InlineKeyboardButton("‚ùå Takibi Bƒ±rak", callback_data=f"remove_{product['id']}")
                        ]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    # Notify user
                    await self.application.bot.send_message(
                        chat_id=product['user_id'],
                        text=message,
                        reply_markup=reply_markup,
                        parse_mode='Markdown',
                        disable_web_page_preview=True
                    )
                    
                    # Update product in database
                    self.db.update_product(
                        product_id=product['id'],
                        title=product_info['title'],
                        price=product_info['price'],
                        in_stock=product_info['in_stock']
                    )
                    
                    logger.info(f"Notified user {product['user_id']} about changes to product {product['id']}")
                
            except Exception as e:
                logger.error(f"Error checking product {product['id']}: {e}", exc_info=True)
        
        logger.info("Completed periodic check of all products")

    def start(self):
        """Start the bot"""
        logger.info("Starting the Telegram bot")
        
        # Set up the periodic product check job
        job_queue = self.application.job_queue
        job_queue.run_repeating(
            self._scheduled_check_products, 
            interval=timedelta(minutes=PRODUCT_CHECK_INTERVAL_MINUTES),
            first=timedelta(minutes=1)  # Start first check after 1 minute
        )
        logger.info(f"Scheduled product checks every {PRODUCT_CHECK_INTERVAL_MINUTES} minutes")
        
        # Start the bot with polling
        self.application.run_polling(allowed_updates=Update.ALL_TYPES)
    
    def stop(self):
        """Stop the bot"""
        logger.info("Stopping the Telegram bot")
        
        # Stop the bot
        if self.application:
            self.application.stop()
